<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Fusca Simulator</title>
    <link rel="shortcut icon" href="imgs/fuscamenu.png" type="image/x-icon">
    <script src="js/cars.js"></script>
    <script src="js/hud.js"></script>
    <script src="js/audio.js"></script>
    <script src="js/track.js"></script>
    <script src="js/time.js"></script>
    <script src="js/objects.js"></script>

    <script src="js/menuButtons.js"></script>
</head>
<style>
    body {
        margin: 0;
        overflow: hidden;
    }
</style>

<body>
    <canvas id="canvas"></canvas>
    <script>
        const FPS = 30;
        let canvas = document.getElementById("canvas");
        canvas.width = innerWidth;
        canvas.height = innerHeight;
        let context = canvas.getContext("2d")
        let timer = setInterval(menu, 1000 / FPS);

        let markers = false;
        let audios = new Sound();
        let entities = [];
        let players = [new PlayerCar(770, 565, 0, "imgs/fuscarosa.png")];
        entities.push(players[0]);
        let grips =
            [{
                up: 87,
                down: 83,
                left: 65,
                right: 68
            }];

        let track = [
            new Track([
                new Point(0.1595 * innerWidth, 0.4637 * innerHeight),
                new Point(0.0762 * innerWidth, 0.3283 * innerHeight),
                new Point(0.0632 * innerWidth, 0.2599 * innerHeight),
                new Point(0.0632 * innerWidth, 0.1642 * innerHeight),
                new Point(0.0781 * innerWidth, 0.1094 * innerHeight),
                new Point(0.0977 * innerWidth, 0.0821 * innerHeight),
                new Point(0.1237 * innerWidth, 0.0575 * innerHeight),
                new Point(0.1562 * innerWidth, 0.0451 * innerHeight),
                new Point(0.3516 * innerWidth, 0.0451 * innerHeight),
                new Point(0.3841 * innerWidth, 0.0575 * innerHeight),
                new Point(0.4102 * innerWidth, 0.0821 * innerHeight),
                new Point(0.4329 * innerWidth, 0.1163 * innerHeight),
                new Point(0.4447 * innerWidth, 0.1546 * innerHeight),
                new Point(0.4447 * innerWidth, 0.2298 * innerHeight),
                new Point(0.4427 * innerWidth, 0.3051 * innerHeight),
                new Point(0.3464 * innerWidth, 0.4761 * innerHeight),
                new Point(0.3906 * innerWidth, 0.5404 * innerHeight),
                new Point(0.4818 * innerWidth, 0.5472 * innerHeight),
                new Point(0.4948 * innerWidth, 0.5636 * innerHeight),
            ]),
            new Track([
                new Point(0.5827 * innerWidth, 0.5636 * innerHeight),
                new Point(0.5729 * innerWidth, 0.5472 * innerHeight),
                new Point(0.6510 * innerWidth, 0.5446 * innerHeight),
                new Point(0.6667 * innerWidth, 0.5198 * innerHeight),
                new Point(0.6667 * innerWidth, 0.4214 * innerHeight),
                new Point(0.6471 * innerWidth, 0.4008 * innerHeight),
                new Point(0.5729 * innerWidth, 0.3939 * innerHeight),
                new Point(0.5729 * innerWidth, 0.4101 * innerHeight)
            ]),
            new Track([
                new Point(0.5046 * innerWidth, 0.3815 * innerHeight),
                new Point(0.5143 * innerWidth, 0.3639 * innerHeight),
                new Point(0.5104 * innerWidth, 0.2873 * innerHeight),
                new Point(0.5078 * innerWidth, 0.1642 * innerHeight),
                new Point(0.5202 * innerWidth, 0.1177 * innerHeight),
                new Point(0.5469 * innerWidth, 0.0752 * innerHeight),
                new Point(0.5989 * innerWidth, 0.0479 * innerHeight),
                new Point(0.8594 * innerWidth, 0.0479 * innerHeight),
                new Point(0.8950 * innerWidth, 0.0615 * innerHeight),
                new Point(0.9245 * innerWidth, 0.0889 * innerHeight),
                new Point(0.9544 * innerWidth, 0.1505 * innerHeight),
                new Point(0.9544 * innerWidth, 0.7798 * innerHeight),
                new Point(0.9440 * innerWidth, 0.8276 * innerHeight),
                new Point(0.9115 * innerWidth, 0.8682 * innerHeight),
                new Point(0.8724 * innerWidth, 0.8919 * innerHeight),
                new Point(0.1497 * innerWidth, 0.8919 * innerHeight),
                new Point(0.1042 * innerWidth, 0.8682 * innerHeight),
                new Point(0.0651 * innerWidth, 0.8079 * innerHeight),
                new Point(0.0638 * innerWidth, 0.7114 * innerHeight),
                new Point(0.0684 * innerWidth, 0.6223 * innerHeight),
                new Point(0.1595 * innerWidth, 0.4637 * innerHeight)
            ]),
            new Track([
                new Point(0.2604 * innerWidth, 0.6334 * innerHeight),
                new Point(0.3151 * innerWidth, 0.7045 * innerHeight),
                new Point(0.7161 * innerWidth, 0.7045 * innerHeight),
                new Point(0.7617 * innerWidth, 0.6703 * innerHeight),
                new Point(0.7910 * innerWidth, 0.6156 * innerHeight),
                new Point(0.7910 * innerWidth, 0.3691 * innerHeight),
                new Point(0.7682 * innerWidth, 0.3016 * innerHeight),
                new Point(0.7357 * innerWidth, 0.2687 * innerHeight),
                new Point(0.6966 * innerWidth, 0.2600 * innerHeight),
                new Point(0.6803 * innerWidth, 0.2600 * innerHeight),
                new Point(0.6641 * innerWidth, 0.2462 * innerHeight),
                new Point(0.6641 * innerWidth, 0.2189 * innerHeight),
                new Point(0.6803 * innerWidth, 0.2051 * innerHeight),
                new Point(0.8105 * innerWidth, 0.2051 * innerHeight),
                new Point(0.8255 * innerWidth, 0.2243 * innerHeight),
                new Point(0.8255 * innerWidth, 0.7100 * innerHeight),
                new Point(0.8112 * innerWidth, 0.7382 * innerHeight),
                new Point(0.2148 * innerWidth, 0.7430 * innerHeight),
                new Point(0.1986 * innerWidth, 0.7243 * innerHeight),
                new Point(0.1986 * innerWidth, 0.7100 * innerHeight),
                new Point(0.2604 * innerWidth, 0.6334 * innerHeight)
            ]),
            new Track([
                new Point(0.2558 * innerWidth, 0.2873 * innerHeight),
                new Point(0.1986 * innerWidth, 0.2189 * innerHeight),
                new Point(0.1986 * innerWidth, 0.2051 * innerHeight),
                new Point(0.3125 * innerWidth, 0.2051 * innerHeight),
                new Point(0.3125 * innerWidth, 0.2189 * innerHeight),
                new Point(0.2558 * innerWidth, 0.2873 * innerHeight),
            ])
        ]
        let lapLines = [
            new LapLine([
                new Point(0.5741 * innerWidth, 0.75 * innerHeight),
                new Point(0.5741 * innerWidth, 0.89 * innerHeight)]),
            new LapLine([
                new Point(0.85 * innerWidth, 0.05 * innerHeight),
                new Point(0.815 * innerWidth, 0.21 * innerHeight)]),
            new LapLine([
                new Point(0.47 * innerWidth, 0.55 * innerHeight),
                new Point(0.47 * innerWidth, 0.7 * innerHeight)]),
            new LapLine([
                new Point(0.065 * innerWidth, 0.21 * innerHeight),
                new Point(0.197 * innerWidth, 0.21 * innerHeight)]),
            new LapLine([
                new Point(0.255 * innerWidth, 0.05 * innerHeight),
                new Point(0.255 * innerWidth, 0.2 * innerHeight)]),
            new LapLine([
                new Point(0.313 * innerWidth, 0.21 * innerHeight),
                new Point(0.443 * innerWidth, 0.21 * innerHeight)]),
        ];
        for (let i = 0; i < track.length; i++) {
            entities.push(track[i]);
        }

        let hud = new Hud();
        let objects = new Objects();
        let laps = 1;
        let timeManager = new TimeManager();

        //MENU
        let menuOptions = 0;
        let inMenu = false;
        let contMenu = 0;
        let buttons = new Buttons([
            new Button(innerWidth * .05, innerHeight * .1, innerWidth * .3, innerHeight * .1, "Jogar", 0),
            new Button(innerWidth * .05, innerHeight * .3, innerWidth * .3, innerHeight * .1, `Players: ${players.length}`, 1),
            new Button(innerWidth * .05, innerHeight * .5, innerWidth * .3, innerHeight * .1, "Customizações", 2),
            new Button(innerWidth * .05, innerHeight * .7, innerWidth * .3, innerHeight * .1, "Configurações", 3),
        ]);

        function menu() {
            inMenu = true;
            background();
            let bg = new Image();
            bg.src = "imgs/fuscamenu.png";
            context.drawImage(bg, 100, 50, innerWidth - 100, innerHeight - 100);
            txt(innerWidth * 0.83, 70, "Super Fusca", 60, "#FBA206");
            txt(innerWidth * 0.84, 120, "Simulator", 60, "#FBA206");

            contMenu++;
            if (contMenu >= FPS / 8) {
                if (keys[83]) {
                    menuOptions = (menuOptions + 1) % buttons.list.length;
                    contMenu = 0;
                };
                if (keys[87]) {
                    menuOptions = (menuOptions - 1 + buttons.list.length) % buttons.list.length;
                    contMenu = 0;
                };
                if (keys[13]) {
                    buttons.list[menuOptions].press();
                    contMenu = 0;
                }
            }
            buttons.update();
        }

        document.addEventListener("mousedown", mousemenu);
        function mousemenu(event) {
            if (inMenu) {
                let mouse = {
                    x: event.clientX,
                    y: event.clientY,
                    width: 0,
                    height: 0,
                };
                for (let i = 0; i < buttons.list.length; i++) {
                    if (buttons.list[i].collide(mouse)) {
                        menuOptions = i;
                        buttons.list[i].press();
                    }
                }
            }
        }
        let ticktack = 4; //segundos
        function tickTack() {
            inMenu = false;
            ticktack -= 1 / FPS;
            background();
            audios.tokyo.play();
            for (let i = 0; i < players.length; i++) {
                players[i].draw();
            }
            objects.draw();

            hud.update();
            if (Math.trunc(ticktack) == 0) {
                clearInterval(timer);
                timer = setInterval(loop, 1000 / FPS);
            } else {
                txt(innerWidth / 2, innerHeight / 2, Math.trunc(ticktack), 70, "white", "center");
            }
        }


        function loop() {
            inMenu = false;
            let finishAll = 0;

            if (!timeManager.acting) {
                for (let i = 0; i < players.length; i++) {
                    players[i].update();
                    finishAll += players[i].finished;
                };
            };

            if (!timeManager.acting && keys[70]) {
                timeManager.replayDuration = Math.min(players[0].savedPositions.length, FPS * timeManager.secReplay);
                timeManager.replayCount = timeManager.replayDuration - 1;
                timeManager.replayZoom = 1.4;
                timeManager.acting = 2;
            };

            if (timeManager.acting == 2) {
                let camera = CenterOfCars();
                context.save();
                context.translate(innerWidth / 2, innerHeight / 2);
                context.scale(timeManager.replayZoom, timeManager.replayZoom);

                let margin = {
                    x: (innerWidth / timeManager.replayZoom) / 2, // o quanto a camera ve depois do scael
                    y: (innerHeight / timeManager.replayZoom) / 2
                };

                // if (camera.x < margin.x) {
                //     camera.x = margin.x;
                // };
                // if (camera.x > (innerWidth - margin.x)) {
                //     camera.x = innerWidth - margin.x;
                // };
                camera.x = ((margin.x) * (camera.x < margin.x)) + ((innerWidth - margin.x) * (camera.x > (innerWidth - margin.x))) + (camera.x * (camera.x >= margin.x && camera.x <= (innerWidth - margin.x)));
                // if (camera.y < margin.y) {
                //     camera.y = margin.y;
                // };
                // if (camera.y > (innerHeight - margin.y)) {
                //     camera.y = innerHeight - margin.y;
                // };
                camera.y = ((margin.y) * (camera.y < margin.y)) + ((innerHeight - margin.y) * (camera.y > (innerHeight - margin.y))) + (camera.y * (camera.y >= margin.y && camera.y <= (innerHeight - margin.y)));
                context.translate(-camera.x, -camera.y);

                background();
                for (let i = 0; i < players.length; players[i].draw(), i++);
                objects.draw();
                if (markers) {
                    for (let i = 0; i < lapLines.length; lapLines[i].draw(), i++);
                    for (let i = 1; i < entities.length; entities[i].draw(), i++);
                }

                timeManager.replay();

                if (timeManager.replayCount === -1) {
                    timeManager.replayCount = timeManager.replayDuration;
                    timeManager.replayZoom = 1;
                    timeManager.acting = 0;
                }

                context.restore();

            } else {

                background();
                for (let i = 0; i < players.length; players[i].draw(), i++);
                objects.draw();
                if (players[0].savedPositions.length > 0) {
                    timeManager.acting = 0;
                    for (let i = 9; i > 0; i--) {
                        if (keys[48 + i]) {
                            timeManager.rewind(i);
                            timeManager.acting = 1;
                            break;
                        }
                    }
                } else {
                    timeManager.acting = 0;
                }
            }

            if (finishAll < players.length) {
                hud.update();
            } else {
                clearInterval(timer);
                timer = setInterval(endGame, 1000 / FPS);
            }
            if (markers && !timeManager.acting) {
                for (let i = 0; i < lapLines.length; lapLines[i].draw(), i++);
                for (let i = 1; i < entities.length; entities[i].draw(), i++);
            }
        }


        function endGame() {
            background();
            for (let i = 0; i < players.length; i++) {
                players[i].update();
                players[i].draw();
            };
            objects.draw();


            context.fillStyle = "rgba(0, 0, 0, .4)";
            context.fillRect(innerWidth / 2 - 300, innerHeight / 2 - 300, 600, 200);
            if (players.length == 2) {
                txt(innerWidth / 2, innerHeight / 2 - 250, `Vencedor: ${players[0].time < players[1].time ? "Player1" : "Player2"}`, 60, "white", "center");
                txt(innerWidth / 2, innerHeight / 2 - 200, `Tempo: ${Math.trunc(players[0].time < players[1].time ? players[0].time : players[1].time)}s`, 50, "white", "center");
            } else {
                txt(innerWidth / 2, innerHeight / 2 - 250, `Vencedor: Player1`, 60, "white", "center");
                txt(innerWidth / 2, innerHeight / 2 - 150, `Tempo: ${(Math.trunc(players[0].time * 100)) / 100}s`, 50, "white", "center");
            }
        }


        function CenterOfCars() {
            let centerCars = { x: 0, y: 0 };
            for (let i = 0; i < players.length; i++) {
                let center = players[i].center();
                centerCars.x += center.x;
                centerCars.y += center.y;
            };
            centerCars.x /= players.length;
            centerCars.y /= players.length;
            return centerCars;
        }

        let config = {
            cont: 0,
            tic: 0
        };
        function configuration() {
            if (config.tic == 0) {
                buttons = new Buttons([]);
                let preButtons = [];
                for (let i = 0; i < players.length; i++) {
                    preButtons.push(
                        new Button(innerWidth * 0.05 + i * (innerWidth * 0.4), innerHeight * 0.2 + innerHeight * 0.0, innerWidth * 0.3, innerHeight * 0.1, `Acelerar`, 4 + i * 4),
                        new Button(innerWidth * 0.05 + i * (innerWidth * 0.4), innerHeight * 0.2 + innerHeight * 0.2, innerWidth * 0.3, innerHeight * 0.1, `Ré / Freio`, 5 + i * 4),
                        new Button(innerWidth * 0.05 + i * (innerWidth * 0.4), innerHeight * 0.2 + innerHeight * 0.4, innerWidth * 0.3, innerHeight * 0.1, `Volante Esq.`, 6 + i * 4),
                        new Button(innerWidth * 0.05 + i * (innerWidth * 0.4), innerHeight * 0.2 + innerHeight * 0.6, innerWidth * 0.3, innerHeight * 0.1, `Volante Dir.`, 7 + i * 4)
                    );
                };
                buttons.list = preButtons;
                inMenu = true;
                menuOptions = 4;
            };
            config.cont++;
            config.tic++;
            background();

            if (config.cont >= FPS / 8) {
                if (keys[83]) {
                    menuOptions = (menuOptions + 1) % buttons.list.length;
                    config.cont = 0;
                };
                if (keys[87]) {
                    menuOptions = (menuOptions - 1 + buttons.list.length) % buttons.list.length;
                    config.cont = 0;
                };
                if (keys[13]) {
                    buttons.list[menuOptions].press();
                    config.cont = 0;
                }
            }

            buttons.update();
        }

        function background() {
            const bg = new Image();
            bg.src = "imgs/racetrack.png";
            context.drawImage(bg, 0, 0, innerWidth, innerHeight);
        }



        let keys = [];
        document.addEventListener("keydown", onKeyD);
        document.addEventListener("keyup", onKeyU);

        function onKeyD(event) {
            keys[event.keyCode] = true;
            console.log(event.keyCode)
        };

        function onKeyU(event) {
            keys[event.keyCode] = false;
        };

        function txt(x, y, tex, px, clr, align) {
            context.font = `${px}px Arial`;
            context.textAlign = align;
            context.textBaseline = 'middle';
            context.fillStyle = clr;
            context.fillText(tex, x, y);
        };
    </script>
</body>

</html>



<!-- 632 linhas -->